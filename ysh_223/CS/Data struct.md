 [[CS]]
###선형 자료구조

- 순차 리스트
- 연결 리스트
- 스택
- 큐
- 덱

### 비선형 구조

- 트리
- 그래프

---

### 희소행렬 Sparse Matrix

- 따로 표를 가짐
    
- list[10][10]이 있고, [0][0]위치에 2가 있다면
    
    ⇒ <0, 0, 2> 와 같은 <x, y, 값> 으로 이뤄진 표가 있음
    

### 스택 Stack

- 마지막에 들어간 값이 가장 먼저 나옴 (LIFO)
- 괄호 검사 & 후위 표기법 변환 등에 활용

### 큐 Queue

- 먼저 들어간 값이 먼저 나옴 (FIFO)
- 운영체제 & 시뮬레이션 큐잉에서 활용됨

### 순차 큐 Linear Queue

- 삽입 : rear = rear + 1
- 삭제 : front = front + 1
- 공백 : front == rear
- 포화 : rear == n - 1

## 원형 큐 Circle Queue

- 삽입 : rear = (rear + 1) % n
- 삭제 : front = (front + 1) % n
- 공백 : front == rear
- 포화 : (rear + 1) % n = front

### 덱 Deque

- 삽입 & 삭제를 양쪽 끝에서 할 수 있다

### 트리 Tree

- 1 : n 관계의 비선형 자료구조
- 계층형 자료구조이다

### 이진 트리

- 트리의 모든 노드의 차수를 2로 제한 (자식이 2개)
- 순차 이진 트리에서
    - 부모 노드 : 현재 idx / 2
    - 왼쪽 자식 : 현재 idx * 2
    - 오른쪽 자식 : 현재 idx * 2 + 1
- 순회
    - D : 현재 노드, L : 현재 노드의 왼쪽 노드, R : 현재 노드의 오른쪽 노드
    - 중위순회 Inorder : L → D → R
    - 전위순회 Preorder : D → L → R
    - 후위순회 Postorder : L → R → D

### 스레드 이진 트리

![[Pasted image 20260111190329.png]]
위와 같이 양옆의 노드를 화살표로 접근 가능

### 이진 탐색 트리 BST

- 원소의 크기에 따라 노드의 위치를 정하여 배치한 트리
- 부모 노드보다 작다면 왼쪽, 크다면 오른쪽
- 자식이 2개인 부모 노드를 삭제할 때
    - 왼쪽에서 가장 큰 노드랑 교체
    - 오른쪽에서 가장 작은 노드랑 교체

### 균형 이진 탐색 트리 Balanced Binary Search Tree

- 균형이 맞다면, 탐색의 성능이 높다
    
    - 균형을 맞추기 위한 회전이 있다
        - LL
            
        - RR
            
        - LR : RR → LL
            
        - RL : LL → RR
            
            ![[Pasted image 20260111190514.png]]
            야메 회전법
            
        - RL회전을 하다 오른쪽 자식이 있을 때, 그 자식을 기준 노드의 부모 노드와 연결
            
        - LL을 할지 RL을 할지가 고민되면 더 깊은 방향으로 회전
            
- 아래의 사진과 같이
    
    ![[Pasted image 20260111190435.png]]
    
    - 왼쪽은 +1
    - 오른쪽은 -1
    - 노드의 개수를 따지는 것이 아니고 층을 따지는 것임
- 회전은 BF가 |2| 이상일 때 일어난다
    

### AVL

- 균형 이진 트리와 같다
- BF를 1 이하로 유지하려 하는 트리

### 트리에서 히프 연산

- 삽입
    
    1. 완전 이진 트리를 위해 일단 트리를 채운다
        
    2. 현재 들어간 노드와 부모 노드와 비교하며 값 교체
        ![[Pasted image 20260111190455.png]]
        
- 삭제
    
    1. 완전 이진 트리를 위해 가장 마지막 idx 번호를 삭제한다
    2. idx안에 값은 잠시 루트에 저장한다
    3. 다시 히프 연산을 통해 트리를 완성한다
- idx
    
    - 부모 idx : 현재 idx / 2
    - 왼쪽 idx : 현재 idx * 2
    - 오른쪽 idx : 현재 * 2 + 1

---

### 선택 정렬

- 배열 중 가장 작은 원소를 고름
- 앞에서부터 정렬됨
- O(n제곱)의 시간 복잡도를 가짐

### 버블 정렬

- 인접한 원소 두 개를 비교해 정렬
- 뒤에서부터 정렬됨
- O(n제곱)

### 퀵 정렬

- 다음 두 작업을 한다
    - 분할 : 정렬할 부분을 기준값으로 나눠 부분집합을 만든다
    - 정복 : 부분집합 안에서 정렬 위치를 정함
- 피봇을 기준으로 다음과 같은 규칙으로 정렬한다
    1. L이 피봇보다 크거나 같은 원소를 찾으면 L로 표시한다, R과 만나면 멈춤
    2. R이 피봇보다 작은 원소를 찾으면 R로 표시한다, L과 만나면 멈춤
    3. L과 R이 각 원소를 찾으면 서로 교체 후, L과 R의 각자 위치에서 다시 작업 수행
    4. L과 R이 만나면 R과 피봇을 교체 후 위치 확정
- O(n log n)의 시간복잡도를 가진다
- 앞에서 시작 피봇 코드 봐야함

### 삽입 정렬

- 앞에서부터 정렬된다
- 앞에서부터 앞에 정렬된 숫자들과 비교하며 삽입해간다
- 순차 정렬된 경우는 O(n)
- 역순 정렬된 경우는 O(n 제곱)
- 값들의 정렬 상태에 따라 시간복잡도가 달라짐

### 셸 정렬

- 일정한 간격으로 떨어진 자료끼리 부분 집합을 구성해 정렬
- 삽입 정렬 O(n제곱)의 개선된 O(n1.25)의 시간복잡도를 가진다
- intervalSort함수를 가진다

### 병합 정렬

- 여러 개의 정렬된 자료 집합을 병합하여 하나의 정렬된 집합으로 만듦
- 분할 시 트리 형태를 띈다
- O(n log n)의 시간복잡도를 가진다

### 기수 정렬

- 비교를 하지 않는다
- 처음엔 일의자리를 각 버킷에, 다음은 십의자리를 각 버킷에 넣으며 정렬
- 정렬 원소 n개를 r개의 버킷에 분배 (n + r), 작업을 자릿수 d만큼 반복은 O(d(n + r))의 시간복잡도를 가짐
- 공간복작도도 엄청남

### 히프 정렬

### 트리 정렬

각 정렬들이 어떤 모습으로 정렬되는지 시각적으로 그려보기

ex ) 앞에서부터 정렬, 트리 형태로 정렬

피봇이 start인 정렬 보기