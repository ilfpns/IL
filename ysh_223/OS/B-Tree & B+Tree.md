## B-tree

이진트리에서 발전되어 모든 리프노드들이 같은 레벨을 가질 수 있도록 자동으로 밸런스를 맞추는 트리

### 특징

1. 하나의 노드에 많은 수의 정보를 가질 수 있다
    
2. 각 노드에 데이터는 정렬된다
    
    ⇒ {10}{12}{14}{15}
    
3. 최대 M개의 자식을 가질 수 있다
    
    ⇒ M차 B트리라고 한다
    
4. 노드의 데이터가 k개라면, 자식 노드 개수는 k + 1개이다
    
    ⇒ 노드 데이터가 2개면, 자식 노드는 3개이다
    
5. 왼쪽은 key보다 작은 값을, 오른쪽은 key보다 큰 값을 구성한다
    
6. 모든 리프 노드들이 같은 레벨에 존재한다
    

- 리프 노드
    
    자식이 단 하나도 없는 말단 노드를 의미함
    

![[Pasted image 20260222012413.png]]

```c
1. 하나의 노드에 여러 정보(값)을 저장함
2. 각 노드의 값은 정렬됨
3. 최대 3개의 자식 노드를 가지므로 3차 B트리
4. root의 노드 안 정보는 2개이므로, 자식 노드는 3개
5. 특정 key를 기준으로 왼쪽은 작은 값, 오른쪽은 큰 값이 구성됨
6. 리프 노드들이 같은 층에 속한다
```

## B+Tree

⇒ 멀티레벨 인덱싱을 통한 빠른 검색을 위해 B-Tree에 2가지 기능이 추가됨

- 리프 노드 연결 리스트화
- 중간 노드 이정표화

### 왜 B-Tree 대신 사용하는가?

⇒ B-Tree는 탐색을 위해 노드를 찾으며 모든 데이터를 순회해야 한다

⇒ B+Tree는 같은 레벨의 모든 키값이 정렬되어 있고, 같은 레빌의 동기 node끼리는 연결리스트로 이어져 있다

![[Pasted image 20260222012429.png]]

1. 리프 노드에는 실제 데이터만 저장됨
2. 키 값의 중복을 허용하지 않음
3. 리프 노드는 연결 히스트로 이어짐

### 의문점

```c
key = 4
그냥 B-Tree로 7->4 해서 찾는 게 낫지 않나?
귀찮게 B+Tree방식으로 7->4->4 로 찾아야 하나? 이게 왜 효율적이지?
```

1. 무조건 말단 노드까지 가므로 전급 횟수가 같고, 예측이 가능함
2. 계층이 훨씬 적어짐

### 멀티레벨 인덱싱

⇒ 1, 2, 3, … n차 형식으로 인덱스를 멀티플하게 나눔
### 실전 적용

1. OS는 프로세스에게 가상 메모리를 주어 메모리 사용 제한을 크게 늘려줌
2. 하지만 이건 가상 메모리로, 실제로 다 사용하지 않고, 사용할 수 없음
3. 메모리가 4GB중 4KB만 사용한다면? 나머지 메모리는 손해
4. 멀티레벨 인덱싱 시작
5. 2GB 보다 적음 → 1GB보다 적음 → … → 4KB보다 크거나 작음
6. 다음과 같이 사용하는 만큼만 할당, 나머지는 NULL 처리