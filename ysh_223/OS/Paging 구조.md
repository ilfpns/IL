## Paging
[[OS]]
---

가상 메모리를 고정 크기 페이지 (Frame size = Page size)로 나누고, 이를 물리 프레임에 매핑하여 외부 단편화 문제를 해결하는 메모리 기법

이런 페이징에는 문제점이 두가지 있다

1. 내부 단편화페이지 단우
2. Page Table이 메모리에 함께 적재됨

이번 글에서는 2번에 대해 다룬다

문제 발생 시나리오 (32bit 체제 CPU 기준)

1. 메모리는 최대 4GB의 가상 주소를 가질 수 있다 (2^32)
    1. 프로세스에게 주어지는 최소 메모리는 4KB이다
2. 단일 레벨 페이지 테이블은 혹시라도 4GB 중 어디를 접근할지 모름
3. 2^20 까지 대응되는 페이지 테이블을 확보해놓음
    - 왜 2^20인가?
        
        - 4GB = 2^32 byte
        - 4KB = 2^12 byte
        
        ⇒ 페이지 테이블은 페이지 단위 매핑을 하기 때문에
        
        4GB (페이지 테이블) / 4KB (페이지 단위)
        
        - 왜 4KB로 나누는가?
            
            OS가 메모리를 페이지 단위(4KB)로 관리하기 때문
            
            - 페이지 테이블에 적당함
            - TLB에 부담을 주지 않음
            - 내부 단편화 감소
            
            ⇒ 적절함
            

이러한 메모리 문제를 해결하는 3가지 방법이 있다

- 계층적 : 안 쓰는 구역 테이블은 만들지 않음
    
    ### 계층적 페이지 테이블 (Hierarchical)
    
    > 한 번에 1M개 다 만들지 말고
    > 
    > 필요한 구역만 만들어 사용
    
    ```c
    10bit + 10bit
    ```
    
    다음과 같이 2level로 나눔
    
    ⇒ 실제 사용하는 구역의 안쪽 테이블만 생성
    
    단점
    
    - 메모리 참조가 늠
- 해시 : 배열 대신 해시 사용
    
- 역페이지 : 물리 메모리 기준 1개만 생성